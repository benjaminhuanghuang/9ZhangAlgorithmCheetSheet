
## 二分法Binary Search

使用条件
- 排序数组(30-40%是二分)
- 当面试官要求你找一个比O(n) 更小的时间复杂度算法的时候(99%)
- 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(100%)
- 找到一个最大/最小的值使得某个条件被满足(90%)

复杂度
- 时间复杂度：O(logn)
- 空间复杂度：O(1)

## 双指针Two Pointers
使用条件
- 滑动窗口(90%)
- 时间复杂度要求O(n) (80%是双指针)
- 要求原地操作，只可以使用交换，不能使用额外空间(80%)
- 有子数组subarray /子字符串substring 的关键词(50%)
- 有回文Palindrome 关键词(50%)

复杂度
- 时间复杂度：O(n)
- 时间复杂度与最内层循环主体的执行次数有关
- 与有多少重循环无关
- 空间复杂度：O(1)
- 只需要分配两个指针的额外内存

## 排序算法Sorting

## 二叉树分治Binary Tree Divide & Conquer

## 二叉搜索树非递归 BST Iterator

## 宽度优先搜索BFS

## 深度优先搜索DFS

## 动态规划 Dynamic Programming
使用场景：
- 求方案总数(90%)
- 求最值(80%)
- 求可行性(80%)

不适用的场景：
- 找所有具体的方案（准确率99%）
- 输入数据无序(除了背包问题外，准确率60%~70%)
- 暴力算法已经是多项式时间复杂度（准确率80%）


动态规划四要素(对比递归的四要素)：
- 状态(State) -- 递归的定义
- 方程(Function) -- 递归的拆解
- 初始化(Initialization) -- 递归的出口
- 答案(Answer) -- 递归的调用

时间复杂度:
- O(状态总数* 每个状态的处理耗费)
- O(状态总数* 决策数)

### 背包型, 01 背包, 多重背包
- 给出n 个物品及其大小,问是否能挑选出一些物品装满大小为m 的背包
- 题目中通常有“和”与“差”的概念，数值会被放到状态中
- 通常是二维的状态数组，前i 个组成和为j 状态数组的大小需要开(n + 1) * (m + 1)

01 背包
- 状态state
dp[i][j] 表示前i 个数里挑若干个数是否能组成和为j
- 方程function
dp[i][j] = dp[i - 1][j] or dp[i - 1][j - A[i - 1]] 如果j >= A[i - 1]
dp[i][j] = dp[i - 1][j] 如果j < A[i - 1]
第i 个数的下标是i - 1，所以用的是A[i - 1] 而不是A[i]
- 初始化initialization
dp[0][0] = true
dp[0][1...m] = false
- 答案answer
使得dp[n][v], 0 s <= v <= m 为true 的最大v


多重背包
- 状态state
dp[i][j] 表示前i 个物品挑出一些放到j 的背包里的最大价值和

- 方程function
dp[i][j] = max(dp[i - 1][j - count * A[i - 1]] + count * V[i - 1])
其中0 <= count <= j / A[i - 1]

- 初始化initialization
dp[0][0..m] = 0

- 答案answer
dp[n][m]


### 区间型
- 题目中有subarray / substring 的信息
- 大区间依赖小区间
- 用dp[i][j] 表示数组/字符串中i, j 这一段区间的最优值/可行性/方案总数


- 状态state
dp[i][j] 表示数组/字符串中i,j 这一段区间的最优值/可行性/方案总数

- 方程function
dp[i][j] = max/min/sum/or(dp[i,j 之内更小的若干区间])


### 匹配型
- 通常给出两个字符串
- 两个字符串的匹配值依赖于两个字符串前缀的匹配值
- 字符串长度为n,m 则需要开(n + 1) x (m + 1) 的状态数组
- 要初始化dp[i][0] 与dp[0][i]
- 通常都可以用滚动数组进行空间优化

状态state
dp[i][j] 表示第一个字符串的前i 个字符与第二个字符串的前j 个字符怎么样怎么样
(max/min/sum/or)


### 划分型
- 是前缀型动态规划的一种, 有前缀的思想
- 如果指定了要划分为几个部分：
  dp[i][j] 表示前i 个数/字符划分为j 个部分的最优值/方案数/可行性
- 如果没有指定划分为几个部分:
▪ dp[i] 表示前i 个数/字符划分为若干个部分的最优值/方案数/可行性

状态state
指定了要划分为几个部分:dp[i][j] 表示前i 个数/字符划分为j 个部分的最优值/方案数/可
行性
没有指定划分为几个部分: dp[i] 表示前i 个数/字符划分为若干个部分的最优值/方案数/可
行性

### 接龙型
- 通常会给一个接龙规则，问你最长的龙有多长
- 状态表示通常为: dp[i] 表示以坐标为i 的元素结尾的最长龙的长度
- 方程通常是: dp[i] = max{dp[j] + 1}, j 的后面可以接上i
- LIS 的二分做法选择性的掌握，但并不是所有的接龙型DP 都可以用二分来优化

- 状态state
  dp[i] 表示以坐标为i 的元素结尾的最长龙的长度
- 方程function
  dp[i] = max{dp[j] + 1}, j 的后面可以接上i



空间复杂度：
- O(状态总数) (不使用滚动数组优化)
- O(状态总数/ n)(使用滚动数组优化, n 是被滚动掉的那一个维度)


## 堆Heap
使用条件
- 找最大值或者最小值(60%)
- 找第k 大(pop k 次复杂度O(nlogk))(50%)
- 要求logn 时间对数据进行操作(40%)

堆不能解决的问题
- 查询比某个数大的最小值/最接近的值（平衡排序二叉树Balanced BST 才可以解决）
- 找某段区间的最大值最小值（线段树SegmentTree 可以解决）
- O(n)找第k 大(使用快排中的partition 操作)

## 并查集Union Find
使用条件
- 需要查询图的连通状况的问题
- 需要支持快速合并两个集合的问题
复杂度
- 时间复杂度union O(1), find O(1)
- 空间复杂度O(n)

## 字典树Trie
使用条件
  查询某个单词 或 前缀是否存在

复杂度
- 时间复杂度O(L) 增删查改 L 是单词长度
- 空间复杂度O(N * L) N 是单词数，L 是单词长度


## Design 
### LRU 缓存
  - 时间复杂度get O(1), set O(1)
  - 空间复杂度O(n) 